; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\retarget.o --depend=.\obj\retarget.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\CMSIS\CM0 -I..\CMSIS\NUC1xx -I..\BSP_Lib\Inc\Driver -I..\BSP_Lib\Inc\NUC1xx-LB_002 -I..\BSP_Lib\Inc\System -I..\BSP_Lib\Inc\USB -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\?ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\retarget.crf ..\BSP_Lib\Src\Driver\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;101    /*---------------------------------------------------------------------------------------------------------*/
;;;102    char GetChar(void)
000000  e008              B        |L1.20|
                  |L1.2|
;;;103    {
;;;104    #if defined(DEBUG_ENABLE_SEMIHOST) && !defined(__ICCARM__) /* IAR don't support semihosted getchar */
;;;105    	int nRet;
;;;106    	while(SH_DoCommand(0x101, 0, &nRet) != 0)
;;;107    	{
;;;108    		if(nRet != 0)
;;;109    		{
;;;110    			SH_DoCommand(0x07, 0, &nRet);
;;;111    			return (char)nRet;
;;;112    		}
;;;113    	}
;;;114    #endif
;;;115    
;;;116    	if(DEBUG_PORT == 1)
;;;117    	{
;;;118    		while (1){
;;;119    			if(UART1->FSR.RX_EMPTY == 0 )
;;;120    			{
;;;121    				return (UART1->DATA);
;;;122    				
;;;123    		    }
;;;124    		}
;;;125    	}
;;;126    	else if(DEBUG_PORT == 0)
;;;127    	{
;;;128    		while (1){
;;;129    			if(UART0->FSR.RX_EMPTY == 0 )
000002  4805              LDR      r0,|L1.24|
000004  6980              LDR      r0,[r0,#0x18]
000006  0440              LSLS     r0,r0,#17
000008  0fc0              LSRS     r0,r0,#31
00000a  d103              BNE      |L1.20|
;;;130    			{
;;;131    				return (UART0->DATA);
00000c  4802              LDR      r0,|L1.24|
00000e  6800              LDR      r0,[r0,#0]
000010  b2c0              UXTB     r0,r0
;;;132    				
;;;133    		    }
;;;134    		}
;;;135    	}
;;;136    	else 
;;;137    	{
;;;138    		while (1){
;;;139    			if(UART2->FSR.RX_EMPTY == 0 )
;;;140    			{
;;;141    				return (UART2->DATA);
;;;142    				
;;;143    		    }
;;;144    		}
;;;145    	}
;;;146    
;;;147    }
000012  4770              BX       lr
                  |L1.20|
000014  e7f5              B        |L1.2|
;;;148    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x40050000

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;164    /*---------------------------------------------------------------------------------------------------------*/
;;;165    int IsDebugFifoEmpty(void)
000000  4802              LDR      r0,|L2.12|
;;;166    {
;;;167    #if(DEBUG_PORT == 0)
;;;168        return UART0->FSR.TE_FLAG;
000002  6980              LDR      r0,[r0,#0x18]
000004  00c0              LSLS     r0,r0,#3
000006  0fc0              LSRS     r0,r0,#31
;;;169    #elif(DEBUG_PORT == 1)
;;;170        return UART1->FSR.TE_FLAG;
;;;171    #else
;;;172        return UART2->FSR.TE_FLAG;
;;;173    #endif    
;;;174    }
000008  4770              BX       lr
;;;175    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40050000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;69     
;;;70     void SendChar(int ch)
000000  b500              PUSH     {lr}
;;;71     {
000002  4603              MOV      r3,r0
;;;72     #if defined(DEBUG_ENABLE_SEMIHOST)
;;;73     	g_buf[g_buf_len++] = ch;
;;;74     	g_buf[g_buf_len] = '\0';
;;;75     	if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
;;;76     	{
;;;77     
;;;78     		/* Send the char */
;;;79     		if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
;;;80             {
;;;81                 g_buf_len = 0;
;;;82     			return;
;;;83             }
;;;84             else
;;;85             {
;;;86                 int i;
;;;87     
;;;88                 for(i=0;i<g_buf_len;i++)
;;;89                     SendChar_ToUART(g_buf[i]);
;;;90     		    g_buf_len = 0;
;;;91             }
;;;92     	}
;;;93     #else
;;;94         SendChar_ToUART(ch);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       SendChar_ToUART
;;;95     #endif
;;;96     }
00000a  bd00              POP      {pc}
;;;97     
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;46     
;;;47     void SendChar_ToUART(int ch)
000000  bf00              NOP      
                  |L4.2|
;;;48     {
;;;49     	if(DEBUG_PORT == 1)
;;;50     	{
;;;51     	    while(UART1->FSR.TX_FULL == 1);
;;;52     		UART1->DATA = ch;
;;;53     	    if(ch == '\n'){
;;;54     	        while(UART1->FSR.TX_FULL == 1);
;;;55     	        UART1->DATA = '\r';
;;;56     	    }
;;;57     	}
;;;58     	else if(DEBUG_PORT == 0)
;;;59     	{
;;;60     		while(UART0->FSR.TX_FULL == 1);
000002  490a              LDR      r1,|L4.44|
000004  6989              LDR      r1,[r1,#0x18]
000006  0209              LSLS     r1,r1,#8
000008  0fc9              LSRS     r1,r1,#31
00000a  2901              CMP      r1,#1
00000c  d0f9              BEQ      |L4.2|
;;;61     		UART0->DATA = ch;
00000e  4907              LDR      r1,|L4.44|
000010  6008              STR      r0,[r1,#0]
;;;62     	    if(ch == '\n'){
000012  280a              CMP      r0,#0xa
000014  d109              BNE      |L4.42|
;;;63     	        while(UART0->FSR.TX_FULL == 1);
000016  bf00              NOP      
                  |L4.24|
000018  4904              LDR      r1,|L4.44|
00001a  6989              LDR      r1,[r1,#0x18]
00001c  0209              LSLS     r1,r1,#8
00001e  0fc9              LSRS     r1,r1,#31
000020  2901              CMP      r1,#1
000022  d0f9              BEQ      |L4.24|
;;;64     	        UART0->DATA = '\r';
000024  210d              MOVS     r1,#0xd
000026  4a01              LDR      r2,|L4.44|
000028  6011              STR      r1,[r2,#0]
                  |L4.42|
;;;65     	    }
;;;66     	}
;;;67     }
00002a  4770              BX       lr
;;;68     
                          ENDP

                  |L4.44|
                          DCD      0x40050000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;178    /*---------------------------------------------------------------------------------------------------------*/
;;;179    void _ttywrch(int ch)
000000  b510              PUSH     {r4,lr}
;;;180    {
000002  4604              MOV      r4,r0
;;;181      SendChar(ch);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SendChar
;;;182      return;
;;;183    }
00000a  bd10              POP      {r4,pc}
;;;184    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;195    
;;;196    int ferror(FILE *f) {
000000  4601              MOV      r1,r0
;;;197      return EOF;
000002  2000              MOVS     r0,#0
000004  43c0              MVNS     r0,r0
;;;198    }
000006  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;190    
;;;191    int fgetc(FILE *f) {
000000  b500              PUSH     {lr}
000002  4601              MOV      r1,r0
;;;192      return (GetChar());
000004  f7fffffe          BL       GetChar
;;;193    }
000008  bd00              POP      {pc}
;;;194    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;184    
;;;185    int fputc(int ch, FILE *f)
000000  b530              PUSH     {r4,r5,lr}
;;;186    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;187      SendChar(ch);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SendChar
;;;188      return ch;
00000c  4620              MOV      r0,r4
;;;189    }
00000e  bd30              POP      {r4,r5,pc}
;;;190    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;151    /*---------------------------------------------------------------------------------------------------------*/
;;;152    int kbhit(void)
000000  4803              LDR      r0,|L9.16|
;;;153    {
;;;154    #if(DEBUG_PORT == 0)
;;;155        return !UART0->FSR.RX_EMPTY;
000002  6980              LDR      r0,[r0,#0x18]
000004  0440              LSLS     r0,r0,#17
000006  0fc0              LSRS     r0,r0,#31
000008  2101              MOVS     r1,#1
00000a  4048              EORS     r0,r0,r1
;;;156    #elif(DEBUG_PORT == 1)
;;;157        return !UART1->FSR.RX_EMPTY;
;;;158    #else
;;;159        return !UART2->FSR.RX_EMPTY;
;;;160    #endif    
;;;161    }
00000c  4770              BX       lr
;;;162    /*---------------------------------------------------------------------------------------------------------*/
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40050000

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000
