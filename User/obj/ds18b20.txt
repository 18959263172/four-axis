; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\ds18b20.o --depend=.\obj\ds18b20.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\CMSIS\CM0 -I..\CMSIS\NUC1xx -I..\BSP_Lib\Inc\Driver -I..\BSP_Lib\Inc\NUC1xx-LB_002 -I..\BSP_Lib\Inc\System -I..\BSP_Lib\Inc\USB -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\?ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\ds18b20.crf ds18b20.c]
                          THUMB

                          AREA ||i.convert_ds18b20||, CODE, READONLY, ALIGN=1

                  convert_ds18b20 PROC
;;;147    **********************************************************************/
;;;148    void convert_ds18b20(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150        if (resetDS18B20()==0xff)
000002  f7fffffe          BL       resetDS18B20
000006  28ff              CMP      r0,#0xff
000008  d105              BNE      |L1.22|
;;;151        {
;;;152            writeByteDS18B20(ds18b20_skip_rom); //跳过ROM
00000a  20cc              MOVS     r0,#0xcc
00000c  f7fffffe          BL       writeByteDS18B20
;;;153            writeByteDS18B20(ds18b20_convert_tem);	//启动温度转换
000010  2044              MOVS     r0,#0x44
000012  f7fffffe          BL       writeByteDS18B20
                  |L1.22|
;;;154        }
;;;155    }
000016  bd10              POP      {r4,pc}
;;;156    
                          ENDP


                          AREA ||i.delay_nus||, CODE, READONLY, ALIGN=1

                  delay_nus PROC
;;;13     **********************************************************************/
;;;14     void delay_nus(unsigned int t)
000000  4601              MOV      r1,r0
;;;15     {
;;;16      unsigned int i=0;
000002  2000              MOVS     r0,#0
;;;17      while(t--)
000004  e004              B        |L2.16|
                  |L2.6|
;;;18        {
;;;19         for(i=0;i<1;i++);
000006  2000              MOVS     r0,#0
000008  e000              B        |L2.12|
                  |L2.10|
00000a  1c40              ADDS     r0,r0,#1
                  |L2.12|
00000c  2800              CMP      r0,#0
00000e  d0fc              BEQ      |L2.10|
                  |L2.16|
000010  460a              MOV      r2,r1                 ;17
000012  1e49              SUBS     r1,r1,#1              ;17
000014  2a00              CMP      r2,#0                 ;17
000016  d1f6              BNE      |L2.6|
;;;20         }
;;;21     }
000018  4770              BX       lr
;;;22     
                          ENDP


                          AREA ||i.get_rom||, CODE, READONLY, ALIGN=1

                  get_rom PROC
;;;115    **********************************************************************/
;;;116    void get_rom(unsigned char* p)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
000002  4604              MOV      r4,r0
;;;118        unsigned char i;
;;;119        if (resetDS18B20()==0xff)
000004  f7fffffe          BL       resetDS18B20
000008  28ff              CMP      r0,#0xff
00000a  d10c              BNE      |L3.38|
;;;120        {
;;;121            writeByteDS18B20(ds18b20_read_rom);
00000c  2033              MOVS     r0,#0x33
00000e  f7fffffe          BL       writeByteDS18B20
;;;122            for (i=0;i<8;i++)
000012  2500              MOVS     r5,#0
000014  e005              B        |L3.34|
                  |L3.22|
;;;123            {
;;;124                *p++ = readByteDS18B20();
000016  f7fffffe          BL       readByteDS18B20
00001a  7020              STRB     r0,[r4,#0]
00001c  1c64              ADDS     r4,r4,#1
00001e  1c68              ADDS     r0,r5,#1              ;122
000020  b2c5              UXTB     r5,r0                 ;122
                  |L3.34|
000022  2d08              CMP      r5,#8                 ;122
000024  dbf7              BLT      |L3.22|
                  |L3.38|
;;;125            }
;;;126        }
;;;127    }
000026  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.readByteDS18B20||, CODE, READONLY, ALIGN=1

                  readByteDS18B20 PROC
;;;60     **********************************************************************/
;;;61     unsigned char readByteDS18B20(void)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
;;;63         unsigned char i;
;;;64         unsigned char retVal=0;
000002  2400              MOVS     r4,#0
;;;65         //RLS_DS18B20;		   //释放总线
;;;66         for (i=8;i>0;i--)
000004  2508              MOVS     r5,#8
000006  e027              B        |L4.88|
                  |L4.8|
;;;67         {
;;;68             retVal>>=1;
000008  1064              ASRS     r4,r4,#1
;;;69             HLD_DS18B20;	   //控制总线
00000a  2201              MOVS     r2,#1
00000c  2104              MOVS     r1,#4
00000e  4610              MOV      r0,r2
000010  f7fffffe          BL       DrvGPIO_Open
;;;70             CLR_DS18B20;	   //强制拉低
000014  2104              MOVS     r1,#4
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       DrvGPIO_ClrBit
;;;71             delay_nus(1);	   //延时大于1us
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       delay_nus
;;;72             SET_DS18B20;	   //释放总线,DS18B20会将总线强制拉低
000022  2104              MOVS     r1,#4
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       DrvGPIO_SetBit
;;;73             RLS_DS18B20;	   //释放总线
00002a  2203              MOVS     r2,#3
00002c  2104              MOVS     r1,#4
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       DrvGPIO_Open
;;;74             delay_nus(1);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       delay_nus
;;;75     
;;;76             if (STU_DS18B20)
00003a  2104              MOVS     r1,#4
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       DrvGPIO_GetBit
000042  2800              CMP      r0,#0
000044  d003              BEQ      |L4.78|
;;;77                 retVal|=0x80;
000046  4620              MOV      r0,r4
000048  2180              MOVS     r1,#0x80
00004a  4308              ORRS     r0,r0,r1
00004c  4604              MOV      r4,r0
                  |L4.78|
;;;78             delay_nus(15);   //31us
00004e  200f              MOVS     r0,#0xf
000050  f7fffffe          BL       delay_nus
000054  1e68              SUBS     r0,r5,#1              ;66
000056  b2c5              UXTB     r5,r0                 ;66
                  |L4.88|
000058  2d00              CMP      r5,#0                 ;66
00005a  dcd5              BGT      |L4.8|
;;;79     
;;;80         }
;;;81         HLD_DS18B20;		   //控制总线 
00005c  2201              MOVS     r2,#1
00005e  2104              MOVS     r1,#4
000060  4610              MOV      r0,r2
000062  f7fffffe          BL       DrvGPIO_Open
;;;82         SET_DS18B20;		   //强制拉高
000066  2104              MOVS     r1,#4
000068  2001              MOVS     r0,#1
00006a  f7fffffe          BL       DrvGPIO_SetBit
;;;83         return(retVal);
00006e  4620              MOV      r0,r4
;;;84     }
000070  bd70              POP      {r4-r6,pc}
;;;85     
                          ENDP


                          AREA ||i.readTempDS18B20||, CODE, READONLY, ALIGN=2

                  readTempDS18B20 PROC
;;;160    **********************************************************************/
;;;161    unsigned int readTempDS18B20(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;162    {
;;;163        unsigned char tempL,tempH,wm0,wm2;
;;;164        unsigned int x;
;;;165    
;;;166        if (resetDS18B20()==0)
000002  f7fffffe          BL       resetDS18B20
000006  2800              CMP      r0,#0
000008  d100              BNE      |L5.12|
                  |L5.10|
;;;167            return 0;
;;;168        writeByteDS18B20(ds18b20_skip_rom);	//跳过ROM
;;;169        writeByteDS18B20(ds18b20_read_ram);	//读数据
;;;170        tempL=readByteDS18B20();
;;;171        tempH=readByteDS18B20();
;;;172        wm0=tempL;
;;;173        wm0=wm0>>4;
;;;174        tempH=tempH<<4;
;;;175        wm2=wm0+tempH; //温度的整数值
;;;176        if (wm2&0x80)  //测试符号位
;;;177        {
;;;178            DS18B20_sign_flag=1;
;;;179            wm2=256-wm2;
;;;180        }
;;;181        else
;;;182            DS18B20_sign_flag=0;
;;;183    
;;;184        x = wm2*100;   //字符型赋给整形,扩大100倍
;;;185    
;;;186        if (tempL&0x08) //提高测试精度
;;;187        {
;;;188            x=x+50;
;;;189        }
;;;190        if (tempL&0x04)
;;;191        {
;;;192            x=x+25;
;;;193        }
;;;194        if (tempL&0x02)
;;;195        {
;;;196            x=x+12;
;;;197        }
;;;198        if (tempL&0x01)
;;;199        {
;;;200            x=x+6;
;;;201        }
;;;202    
;;;203        convert_ds18b20();//启动温度转换
;;;204        return(x);
;;;205    }
00000a  bdf8              POP      {r3-r7,pc}
                  |L5.12|
00000c  20cc              MOVS     r0,#0xcc              ;168
00000e  f7fffffe          BL       writeByteDS18B20
000012  20be              MOVS     r0,#0xbe              ;169
000014  f7fffffe          BL       writeByteDS18B20
000018  f7fffffe          BL       readByteDS18B20
00001c  4604              MOV      r4,r0                 ;170
00001e  f7fffffe          BL       readByteDS18B20
000022  4607              MOV      r7,r0                 ;171
000024  9400              STR      r4,[sp,#0]            ;172
000026  9800              LDR      r0,[sp,#0]            ;173
000028  1100              ASRS     r0,r0,#4              ;173
00002a  9000              STR      r0,[sp,#0]            ;173
00002c  0738              LSLS     r0,r7,#28             ;174
00002e  0e07              LSRS     r7,r0,#24             ;174
000030  9800              LDR      r0,[sp,#0]            ;175
000032  19c0              ADDS     r0,r0,r7              ;175
000034  b2c6              UXTB     r6,r0                 ;175
000036  2080              MOVS     r0,#0x80              ;176
000038  4206              TST      r6,r0                 ;176
00003a  d005              BEQ      |L5.72|
00003c  2001              MOVS     r0,#1                 ;178
00003e  490f              LDR      r1,|L5.124|
000040  7008              STRB     r0,[r1,#0]            ;178
000042  4270              RSBS     r0,r6,#0              ;179
000044  b2c6              UXTB     r6,r0                 ;179
000046  e002              B        |L5.78|
                  |L5.72|
000048  2000              MOVS     r0,#0                 ;182
00004a  490c              LDR      r1,|L5.124|
00004c  7008              STRB     r0,[r1,#0]            ;182
                  |L5.78|
00004e  2064              MOVS     r0,#0x64              ;184
000050  4635              MOV      r5,r6                 ;184
000052  4345              MULS     r5,r0,r5              ;184
000054  2008              MOVS     r0,#8                 ;186
000056  4204              TST      r4,r0                 ;186
000058  d000              BEQ      |L5.92|
00005a  3532              ADDS     r5,r5,#0x32           ;188
                  |L5.92|
00005c  2004              MOVS     r0,#4                 ;190
00005e  4204              TST      r4,r0                 ;190
000060  d000              BEQ      |L5.100|
000062  3519              ADDS     r5,r5,#0x19           ;192
                  |L5.100|
000064  2002              MOVS     r0,#2                 ;194
000066  4204              TST      r4,r0                 ;194
000068  d000              BEQ      |L5.108|
00006a  350c              ADDS     r5,r5,#0xc            ;196
                  |L5.108|
00006c  07e0              LSLS     r0,r4,#31             ;198
00006e  0fc0              LSRS     r0,r0,#31             ;198
000070  d000              BEQ      |L5.116|
000072  1dad              ADDS     r5,r5,#6              ;200
                  |L5.116|
000074  f7fffffe          BL       convert_ds18b20
000078  4628              MOV      r0,r5                 ;204
00007a  e7c6              B        |L5.10|
;;;206    
                          ENDP

                  |L5.124|
                          DCD      DS18B20_sign_flag

                          AREA ||i.resetDS18B20||, CODE, READONLY, ALIGN=1

                  resetDS18B20 PROC
;;;26     **********************************************************************/
;;;27     unsigned char resetDS18B20(void)
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29         unsigned char errTime=0;
000002  2400              MOVS     r4,#0
;;;30         HLD_DS18B20;		   //控制总线
000004  2201              MOVS     r2,#1
000006  2104              MOVS     r1,#4
000008  4610              MOV      r0,r2
00000a  f7fffffe          BL       DrvGPIO_Open
;;;31         CLR_DS18B20;		   //强制拉低       
00000e  2104              MOVS     r1,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       DrvGPIO_ClrBit
;;;32         delay_nus(260);	       //以上延时大于480us
000016  20ff              MOVS     r0,#0xff
000018  3005              ADDS     r0,#5
00001a  f7fffffe          BL       delay_nus
;;;33         SET_DS18B20;
00001e  2104              MOVS     r1,#4
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       DrvGPIO_SetBit
;;;34         RLS_DS18B20;		   //释放总线,总线自动上拉 DDR
000026  2203              MOVS     r2,#3
000028  2104              MOVS     r1,#4
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       DrvGPIO_Open
;;;35         delay_nus(7);          //15~60us
000030  2007              MOVS     r0,#7
000032  f7fffffe          BL       delay_nus
;;;36     
;;;37         while (STU_DS18B20)
000036  e008              B        |L6.74|
                  |L6.56|
;;;38         {
;;;39             delay_nus(3);	   //5.15us
000038  2003              MOVS     r0,#3
00003a  f7fffffe          BL       delay_nus
;;;40             errTime++;
00003e  1c60              ADDS     r0,r4,#1
000040  b2c4              UXTB     r4,r0
;;;41             if (errTime>20)
000042  2c14              CMP      r4,#0x14
000044  dd01              BLE      |L6.74|
;;;42                 return(0x00);  //如果等带大于约 5.15us*20就返回0x00，报告复位失败（实际上只要等待15-60us）
000046  2000              MOVS     r0,#0
                  |L6.72|
;;;43         }
;;;44         errTime=0;
;;;45         while (!(STU_DS18B20))
;;;46         {
;;;47             delay_nus(3);	   //5.15us
;;;48             errTime++;
;;;49             if (errTime>50)
;;;50                 return(0x00);  //如果等带大于约 5.15us*50就返回0x00，报告复位失败（实际上只要等待60-240us）
;;;51         }
;;;52         HLD_DS18B20;		   //控制总线
;;;53         SET_DS18B20;		   //强制拉高
;;;54         return(0xff);
;;;55     }
000048  bd10              POP      {r4,pc}
                  |L6.74|
00004a  2104              MOVS     r1,#4                 ;37
00004c  2001              MOVS     r0,#1                 ;37
00004e  f7fffffe          BL       DrvGPIO_GetBit
000052  2800              CMP      r0,#0                 ;37
000054  d1f0              BNE      |L6.56|
000056  2400              MOVS     r4,#0                 ;44
000058  e008              B        |L6.108|
                  |L6.90|
00005a  2003              MOVS     r0,#3                 ;47
00005c  f7fffffe          BL       delay_nus
000060  1c60              ADDS     r0,r4,#1              ;48
000062  b2c4              UXTB     r4,r0                 ;48
000064  2c32              CMP      r4,#0x32              ;49
000066  dd01              BLE      |L6.108|
000068  2000              MOVS     r0,#0                 ;50
00006a  e7ed              B        |L6.72|
                  |L6.108|
00006c  2104              MOVS     r1,#4                 ;45
00006e  2001              MOVS     r0,#1                 ;45
000070  f7fffffe          BL       DrvGPIO_GetBit
000074  2800              CMP      r0,#0                 ;45
000076  d0f0              BEQ      |L6.90|
000078  2201              MOVS     r2,#1                 ;52
00007a  2104              MOVS     r1,#4                 ;52
00007c  4610              MOV      r0,r2                 ;52
00007e  f7fffffe          BL       DrvGPIO_Open
000082  2104              MOVS     r1,#4                 ;53
000084  2001              MOVS     r0,#1                 ;53
000086  f7fffffe          BL       DrvGPIO_SetBit
00008a  20ff              MOVS     r0,#0xff              ;54
00008c  e7dc              B        |L6.72|
;;;56     
                          ENDP


                          AREA ||i.set_ds18b20||, CODE, READONLY, ALIGN=1

                  set_ds18b20 PROC
;;;132    **********************************************************************/
;;;133    void set_ds18b20(char th,char tl,unsigned char config)
000000  b570              PUSH     {r4-r6,lr}
;;;134    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;135        if (resetDS18B20()==0xff)
000008  f7fffffe          BL       resetDS18B20
00000c  28ff              CMP      r0,#0xff
00000e  d10e              BNE      |L7.46|
;;;136        {
;;;137            writeByteDS18B20(ds18b20_skip_rom);
000010  20cc              MOVS     r0,#0xcc
000012  f7fffffe          BL       writeByteDS18B20
;;;138            writeByteDS18B20(ds18b20_write_ram);
000016  204e              MOVS     r0,#0x4e
000018  f7fffffe          BL       writeByteDS18B20
;;;139            writeByteDS18B20(th);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       writeByteDS18B20
;;;140            writeByteDS18B20(tl);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       writeByteDS18B20
;;;141            writeByteDS18B20(config);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       writeByteDS18B20
                  |L7.46|
;;;142        }
;;;143    }
00002e  bd70              POP      {r4-r6,pc}
;;;144    /**********************************************************************
                          ENDP


                          AREA ||i.writeByteDS18B20||, CODE, READONLY, ALIGN=1

                  writeByteDS18B20 PROC
;;;89     **********************************************************************/
;;;90     void writeByteDS18B20(unsigned char wb)
000000  b570              PUSH     {r4-r6,lr}
;;;91     {
000002  4605              MOV      r5,r0
;;;92         unsigned char i;
;;;93         unsigned char temp;
;;;94     
;;;95         //RLS_DS18B20;	        //释放总线
;;;96         for (i=0;i<8;i++)
000004  2400              MOVS     r4,#0
000006  e027              B        |L8.88|
                  |L8.8|
;;;97         {
;;;98             HLD_DS18B20;		//控制总线
000008  2201              MOVS     r2,#1
00000a  2104              MOVS     r1,#4
00000c  4610              MOV      r0,r2
00000e  f7fffffe          BL       DrvGPIO_Open
;;;99             CLR_DS18B20;		//强制拉低
000012  2104              MOVS     r1,#4
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       DrvGPIO_ClrBit
;;;100            delay_nus(1);	 	//14.92us
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       delay_nus
;;;101            temp=wb>>i;
000020  4628              MOV      r0,r5
000022  4120              ASRS     r0,r0,r4
000024  b2c6              UXTB     r6,r0
;;;102            if (temp&=0x01)
000026  07f0              LSLS     r0,r6,#31
000028  0fc0              LSRS     r0,r0,#31
00002a  0006              MOVS     r6,r0
00002c  d004              BEQ      |L8.56|
;;;103                SET_DS18B20;    //释放总线
00002e  2104              MOVS     r1,#4
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       DrvGPIO_SetBit
000036  e003              B        |L8.64|
                  |L8.56|
;;;104            else
;;;105                CLR_DS18B20;	//强制拉低
000038  2104              MOVS     r1,#4
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       DrvGPIO_ClrBit
                  |L8.64|
;;;106            delay_nus(15);	    //30.38us
000040  200f              MOVS     r0,#0xf
000042  f7fffffe          BL       delay_nus
;;;107            SET_DS18B20;		//释放总线
000046  2104              MOVS     r1,#4
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       DrvGPIO_SetBit
;;;108            delay_nus(1);	 	//2.71us(大于1us就行了)
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       delay_nus
000054  1c60              ADDS     r0,r4,#1              ;96
000056  b2c4              UXTB     r4,r0                 ;96
                  |L8.88|
000058  2c08              CMP      r4,#8                 ;96
00005a  dbd5              BLT      |L8.8|
;;;109        }
;;;110    }
00005c  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  DS18B20_sign_flag
000000  00                DCB      0x00
